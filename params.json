{"name":"Garrulous-octo-tatertot","tagline":"Thread Concepts","body":"(Copied from https://www.gitbook.com/book/hzj163/android-thread/details since written in Chinese.)\r\n\r\nThread\r\nThe concept of process\r\n\r\n  Process is the underlying operating system architecture; is a program being executed; examples of computer program running; an entity processor executed by a processor can be assigned to; the display by a single sequence of execution, a current state and a set of Activities related to system resources unit described. Simply put, when we launch an application, there will be a process. Can be viewed through the Task Manager to the current system which processes. System to process a separate memory space allocated\r\n\r\nThread (Tread)\r\n\r\n  Thread, sometimes referred to as lightweight processes (Lightweight Process, LWP), is the smallest unit of program execution flow. A standard thread by the thread ID, the current instruction pointer (PC), a set of registers and stack components. In addition, the thread is in the process of an entity is the basic unit of the system independent scheduling and dispatching, the thread that they do not have the system resources, with only a little in the operation of essential resources, but it can be used with other threads belong to a process sharing process have all the resources. A thread can create and undo another thread can execute concurrently between multiple threads in the same process. Because of mutual restraint between threads, resulting in the thread showing intermittent in operation.\r\n\r\n  A program has at least one thread, it is the program itself. A thread is a single sequential program control flow. In a single program to run multiple threads to complete different tasks, called multi-threading.\r\n\r\nState of the thread\r\n\r\nNew state (new)\r\nReady state (Runnable)\r\nRunning state (Running)\r\nBlocking state (Blocked)\r\nDeath state (Dead)\r\nThread Synchronization\r\n\r\n  Many threads must be considered in the implementation of shared data or coordination among the other thread execution state. This requires synchronization mechanism. In Java, every object has a corresponding lock. But Java does not provide a separate lock and unlock operations. It is implicitly realized by high-level structure, to ensure the corresponding operation. (However, we note that the Java virtual machine to provide separate instructions monito renter and monitorexit to achieve lock and unlock operations.)\r\n\r\n  synchronized statement evaluates an object reference, trying to complete the locking operation of the object, and stop processing before the completion of lock operations. When the lock operation is complete synchronized statement body is executed. When a statement body is finished (either normal or abnormal), unlocking is done automatically. As object-oriented languages, synchronized methods often used in conjunction. A better approach is that if a variable is assigned by a thread reference or assignment by the other threads, so access to all of the variables have to be within a certain synchromized statement or synchronized methods.\r\n\r\nAndroid UI in the main thread\r\n\r\n  When the application starts, the system creates a main thread (main thread). The main thread is responsible for distributing the event to UI components (including the preparation of the event), also in this main thread, your applications, and Android's UI component interaction occurs. So the main thread that is also called the UI thread UI thread.\r\n\r\n  If all of the work in the UI thread, do some of the more time-consuming work such as access to the network or database queries, will block the UI thread, causing the event to stop distribution (including the preparation of events). For users, the application looks like stuck, even worse is that if the UI thread blocked too long (about more than 5 seconds), the user will see the ANR (application not responding) dialog box.\r\n\r\n  Andoid UI toolkit is not thread-safe, so you can not from a non-UI thread to manipulate UI components. You have to put all UI operations on UI thread, so single-threaded model for Android has two principles:\r\n\r\nDo not block the UI thread.\r\nDo not access the Android UI toolkit beyond the UI thread (the main components in these two packages: android.widget and android.view).\r\n\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nJAVA thread creation\r\n  In JAVA generally two ways to create a thread\r\n\r\nThread class inheritance, rewrite the run method\r\nImplement Runnable interface, rewrite the run method\r\ninternal thread run method lifecycle, run method has finished executing, then the end of the thread lifecycle\r\nAlways use the Thread object start the thread start method\r\nCase inheritance Thread\r\n\r\n\r\n    class  MyRun  extends   Thread\r\n     {\r\n         Override \r\n        public  void  run ()  {\r\n\r\n            for ( int i = 1 ; i <= 100 ; i ++)\r\n            {\r\n                try {\r\n                    Thread.sleep ( 5 );\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace ();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n  public  void  btn1 (View View)\r\n   {\r\n\r\n    MyRun myRun = new MyRun ();\r\n    myRun.start ();\r\n  }\r\nCase implement Runnable Interface\r\n\r\n\r\n    class  MyRun2  implements   Runnable\r\n     {\r\n         Override \r\n        public  void  run ()  {\r\n             for ( int i = 1 ; i <= 100 ; i ++)\r\n            {\r\n                try {\r\n                    Thread.sleep ( 1000 );\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace ();\r\n                }\r\n                Log.i ( \"HZJ\" , i + \"----\" );\r\n            }\r\n        }\r\n    }\r\n\r\n    public  void  btn1 (View View)\r\n   {\r\n      MyRun2 myRun2 = new MyRun2 ();\r\n      Thread Thread = new Thread (myRun2);\r\n      thread.start ();\r\n  }\r\n  In JAVA thread object Thread, Thread therefore there are many ways for us to manage threads\r\n\r\nThread.sleep (ms) blocked and can automatically wake\r\nThread.currentThread () to get the current thread object\r\nThread Status\r\n\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nCycle thread\r\n  In some cases, do not need to let the thread stopped, or how much time to run a thread delay. So this scenario can use Timer and TimeTask java provide binding process\r\n\r\nTimer and TimeTask\r\n\r\n  Timer is a timer jdk tool provided, when in use will play a separate thread to perform the specified scheduled task, you can specify the execution once or repeated several times in addition to the main thread. Timer is a thread, using a schedule to complete the TimerTask scheduling method, Timer object to call a schedule is to create a thread, use the Timer cancel () stops operating. Timer executed once after cancel () method, Timer threads are terminated.\r\n\r\n  Timer There are two modes of schedule\r\n\r\nAfter the implementation of a number of milliseconds\r\n\r\nvoid schedule (TimerTask, Date)\r\nvoid schedule (TimerTask, long)\r\nHow many executed once every millisecond\r\n\r\nvoid schedule (TimerTask, long, long)\r\nvoid schedule (TimerTask, Date, long)\r\n  TimerTask is an abstract class that implements the Runnable interface, on behalf of tasks that can be performed Timer.\r\n\r\nTimer object is created\r\n\r\n\r\nTimer timer;\r\n// Directly instantiated \r\ntimer = new Timer ();\r\nTimeTask object creation\r\n\r\n\r\n    // TimerTask is an abstract class, we need to inherit and implement TimerTask TimerTask run method of \r\n    class  MyTimerTask  extends  TimerTask  {\r\n         Override \r\n        public  void  run ()  {\r\n\r\n        // Here is a new thread\r\n\r\n        }\r\n    }\r\nTimer object to perform tasks TimeTask\r\n\r\n\r\n    timer = new Timer ();\r\n     // delay 0 seconds, and executed once every 1000 milliseconds \r\n    timer.schedule ( new MyTimerTask (), 0 , 1000 );\r\n\r\n    timer = new Timer ();\r\n     // delay 1000 seconds after performing \r\n    timer.schedule ( new MyTimerTask (), 1000 );\r\nEnd Timer thread [If executed executed once every N milliseconds, call cancel () method to end the thread]\r\n\r\n\r\n    // Timer object to close the thread\r\n    timer.cancel ();\r\n    timer = null ;\r\nCase combines the android handler []\r\n\r\n\r\nPackage com.hzj163.mythread;\r\n\r\nImport android.os.Bundle;\r\n Import android.os.Handler;\r\n Import android.os.Message;\r\n Import android.support.v4.app.Fragment;\r\n Import android.view.LayoutInflater;\r\n Import android.view.View;\r\n Import android.view .ViewGroup;\r\n Import android.widget.Button;\r\n Import android.widget.TextView;\r\n\r\nImport java.text.SimpleDateFormat;\r\n Import java.util.Date;\r\n Import java.util.Timer;\r\n Import java.util.TimerTask;\r\n\r\npublic  class  F2  extends  Fragment  {\r\n     // debris view\r\n    View view;\r\n    // Fragments of text objects for display once every passing second time\r\n    TextView textView1;\r\n    // Start button\r\n    Button button1;\r\n    // End button\r\n    Button button2;\r\n    // Timer object\r\n    Timer timer;\r\n\r\n    // TimerTask is an abstract class, we need to inherit and implement TimerTask TimerTask run method of \r\n    class  MyTimerTask  extends  TimerTask  {\r\n         Override \r\n        public  void  run ()  {\r\n             // execute getMyResult () method to get the current date\r\n            String temp = getMyResult ();\r\n            // Send a message to the main UI thread handler objects\r\n            Message message = handler.obtainMessage ();\r\n            // Set the message data\r\n            message.obj = temp;\r\n            // Set the message type \r\n            message.what = 1 ;\r\n             // messaging\r\n            message.sendToTarget ();\r\n        }\r\n    }\r\n\r\n    // Handler object starts waiting for news \r\n    Handler handler = new Handler () {\r\n         Override \r\n        public  void  handleMessage (Message msg)  {\r\n             // receive a message to change the UI\r\n            textView1.setText (msg.obj.toString ());\r\n        }\r\n    };\r\n\r\n\r\n    // Business logic \r\n    public String getMyResult ()  {\r\n         // Get the current date \r\n        Date Date = new Date ();\r\n        SimpleDateFormat SimpleDateFormat = new SimpleDateFormat ( \"yyyy Year MM month dd day HH: mm: SS\" );\r\n        String result = simpleDateFormat.format (date);\r\n        return result;\r\n    }\r\n\r\n    public  void  btn1 (View View)  {\r\n         // instantiate an object timer \r\n        timer = new Timer ();\r\n         // every one second to perform a task MyTimerTask \r\n        timer.schedule ( new MyTimerTask (), 0 , 1000 );\r\n        button1.setEnabled ( false );\r\n    }\r\n\r\n    public  void  btn2 (View View)  {\r\n         // End timer objects thread\r\n        timer.cancel ();\r\n        timer = null ;\r\n        button1.setEnabled ( true );\r\n    }\r\n\r\n\r\n    Override \r\n    public View onCreateView (LayoutInflater inflater, ViewGroup Container,\r\n                             Bundle savedInstanceState)  {\r\n         if (View == null ) {\r\n            View = Inflater.inflate (R.layout.fragment_f2, Container, false );\r\n            textView1 = (TextView) view.findViewById (R.id.textView1);\r\n            button1 = (Button) view.findViewById (R.id.button1);\r\n            button1.setOnClickListener ( new View.OnClickListener () {\r\n                 Override \r\n                public  void  onClick (View v)  {\r\n                    btn1 (v);\r\n                }\r\n            });\r\n            button2 = (Button) view.findViewById (R.id.button2);\r\n            button2.setOnClickListener ( new View.OnClickListener () {\r\n                 Override \r\n                public  void  onClick (View v)  {\r\n                    btn2 (v);\r\n                }\r\n            });\r\n        }\r\n        return View;\r\n    }\r\n\r\n}\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nThread thread synchronization [Security]\r\n  Thread synchronization, referring to the multi-threaded use of shared resources, the program will be wrong in the world, then this error is not thread-safe. Hence the need for thread synchronization process.\r\n\r\n  Use thread synchronization lock mechanism to achieve the purpose of thread synchronization.\r\n\r\n  JAVA synchronized keyword can be used to achieve code level or method-level synchronization.\r\n\r\n  In the synchronization mechanism, ensuring at the same time only one thread access the variable object by locking mechanism. Then the variable is shared by multiple threads, using synchronization mechanisms require careful analysis of program variables when read and write when you need to lock an object, when the object lock release and other complex issues, program design and writing the difficulty is relatively large.\r\n\r\nsynchronized method level, then the synchronization lock object resides for the current method\r\n\r\n\r\n        // Method-level synchronization, object lock object for the change method where the \r\n        public  synchronized  void  server1 ()\r\n         {\r\n\r\n        }\r\nsynchronized code level, then the synchronization lock objects to their own definition of\r\n\r\n\r\n        public  void  server1 ()\r\n         {\r\n             // code segment level synchronized lock object is any object \r\n            // but need to ensure all calls to this code segment thread, have seen the same object is \r\n            synchronized (Object) {\r\n                // synchronous range\r\n            }\r\n        }\r\nCase\r\n\r\n\r\nPackage com.hzj163.mythread;\r\n Import android.os.Bundle;\r\n Import android.os.Handler;\r\n Import android.os.Message;\r\n Import android.support.v4.app.Fragment;\r\n Import android.view.LayoutInflater;\r\n Import android.view .view;\r\n Import android.view.ViewGroup;\r\n Import android.widget.Button;\r\n Import android.widget.TextView;\r\n Import java.util.Random;\r\n Import java.util.Timer;\r\n Import java.util.TimerTask;\r\n\r\npublic  class  F3  extends  Fragment  {\r\n     // shared resource \r\n    int count = 1000 ;\r\n     // synchronized lock object \r\n    Object Object = new Object ();\r\n\r\n    // Four variables recorded four threads resources obtained \r\n    int r1 = 0 ;\r\n     int R2 = 0 ;\r\n     int r3 = 0 ;\r\n     int R4 = 0 ;\r\n\r\n\r\n    // UI\r\n    View view;\r\n    TextView textView1;\r\n    TextView textView2;\r\n    TextView textView3;\r\n    TextView textView4;\r\n    TextView textView5;\r\n    Button button1;\r\n    // Message Object \r\n    Handler handler = new Handler () {\r\n         Override \r\n        public  void  handleMessage (Message msg)  {\r\n             switch (msg.what) {\r\n                 Case  1 :\r\n                    textView1.setText (msg.obj.toString ());\r\n                    r1 = Integer.parseInt (msg.obj.toString ());\r\n                    break ;\r\n                 Case  2 :\r\n                    textView2.setText (msg.obj.toString ());\r\n                    r2 = Integer.parseInt (msg.obj.toString ());\r\n                    break ;\r\n                 Case  3 :\r\n                    textView3.setText (msg.obj.toString ());\r\n                    r3 = Integer.parseInt (msg.obj.toString ());\r\n                    break ;\r\n                 Case  4 :\r\n                    textView4.setText (msg.obj.toString ());\r\n                    r4 = Integer.parseInt (msg.obj.toString ());\r\n                    break ;\r\n            }\r\n\r\n\r\n            textView5.setText (count + \"\" );\r\n             // message object observation resources, if the resource is 0 then initialized \r\n            if (count == 0 ) {\r\n                timer1.cancel ();\r\n                timer2.cancel ();\r\n                timer3.cancel ();\r\n                timer4.cancel ();\r\n                button1.setEnabled ( true );\r\n                r1 = 0 ;\r\n                R2 = 0 ;\r\n                r3 = 0 ;\r\n                R4 = 0 ;\r\n                 // replenished resource \r\n                count = 1000 ;\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    // Four threads\r\n    Timer timer1;\r\n    Timer timer2;\r\n    Timer timer3;\r\n    Timer timer4;\r\n\r\n    // Perform tasks \r\n    class  MyTimeTask  extends  TimerTask  {\r\n         // message type value \r\n        int What;\r\n         // passed in the amount of resources for each task \r\n        int rValue;\r\n\r\n        public  MyTimeTask ( int What, int rValue)  {\r\n             this .what = What;\r\n             this .rValue = rValue;\r\n\r\n        }\r\n\r\n        Override \r\n        public  void  run ()  {\r\n             // synchronize tasks \r\n            synchronized (Object) {\r\n\r\n                Analyzing public resources // \r\n                if (count> 0 ) {\r\n                     // add resources\r\n                    rValue ++;\r\n                    // Reduce public resources\r\n                    count--;\r\n                    //Send a message\r\n                    Message message = handler.obtainMessage ();\r\n                    message.what = what;\r\n                    message.obj = rValue;\r\n                    message.sendToTarget ();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public  void  btn1 (View View)  {\r\n\r\n        // Instantiate thread \r\n        Timer1 = new Timer ();\r\n        Timer2 = new Timer ();\r\n        timer3 = new Timer ();\r\n        Timer4 = new Timer ();\r\n         // random number instantiated, causing the number of milliseconds each thread execution is not the same \r\n        Random random = new Random ();\r\n         int random1 = random.nextInt ( 100 ) + 100 ;\r\n         int random2 = random .nextInt ( 100 ) + 100 ;\r\n         int random3 = random.nextInt ( 100 ) + 100 ;\r\n         int random4 = random.nextInt ( 100 ) + 100 ;\r\n\r\n        // Thread starts executing tasks \r\n        timer1.schedule ( new MyTimeTask ( 1 , r1), 0 , random1);\r\n        timer2.schedule ( new MyTimeTask ( 2 , R2), 0 , random2);\r\n        timer3.schedule ( new MyTimeTask ( 3 , r3), 0 , random3);\r\n        timer4.schedule ( new MyTimeTask ( 4 , R4), 0 , random4);\r\n\r\n        button1.setEnabled ( false );\r\n    }\r\n\r\n    Override \r\n    public View onCreateView (LayoutInflater inflater, ViewGroup Container,\r\n                             Bundle savedInstanceState)  {\r\n\r\n        if (View == null ) {\r\n            View = Inflater.inflate (R.layout.fragment_f3, Container, false );\r\n            textView1 = (TextView) view.findViewById (R.id.textView1);\r\n            textView2 = (TextView) view.findViewById (R.id.textView2);\r\n            textView3 = (TextView) view.findViewById (R.id.textView3);\r\n            textView4 = (TextView) view.findViewById (R.id.textView4);\r\n            textView5 = (TextView) view.findViewById (R.id.textView5);\r\n            button1 = (Button) view.findViewById (R.id.button1);\r\n            button1.setOnClickListener ( new View.OnClickListener () {\r\n                 Override \r\n                public  void  onClick (View v)  {\r\n                    btn1 (v);\r\n                }\r\n            });\r\n        }\r\n        return View;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nThreadLocal\r\n  Use ThreadLocal allows object reaches the thread isolation purposes. Use this variable for each thread provides a copy of the variable value, is in a more special Java thread binding mechanism, every thread can independently change their copy, but not copy and other threads conflict.\r\n\r\nThreadLocal common method\r\n\r\nConstructor: ThreadLocal (): Creates a thread local variable\r\n\r\nprotected T initialValue (): Returns the current thread's initial value for this thread-local variable. Called when the maximum at each visit thread to get each thread-local variable this method once, the first time you use the thread get () method to access the variable time. If the thread is set to get first call method (T) method is not called again initialValue method in the thread.\r\n\r\nT get ():\r\n\r\nvoid set (T value): the current copy of this thread in the thread-local variable is set to the specified value. Many applications do not require this function, they only rely on initialValue () method to set the value of the thread local variables.\r\n\r\nvoid remove (): remove this thread-local variable. This may help reduce the storage requirements of thread-local variables. If you visit this thread-local variable again, then by default it will have its initialValue.\r\n\r\nIn the program generally rewrite initialValue method, given a particular initial value.\r\n\r\nNote ThreadLocal objects where construction will belong to that thread. Not cross thread calls ThreadLocal objects\r\n\r\nNote that all threads finished ThreadLocal objects contained in the time required to reset the properties of an object. ThreadLocal implemented because the method does not clone or copy.\r\n\r\nCase [unpackaged]\r\n\r\nBoss.java\r\n\r\n\r\nPackage com.hzj163.myhandler;\r\n\r\nImport java.util.ArrayList;\r\n\r\n// Copy BOSS \r\npublic  class  Boss  {\r\n\r\n    // Boss name\r\n    String name;\r\n    // Boss falling equipment\r\n    ArrayList <String> equipment;\r\n    // If death \r\n    boolean Dead;\r\n\r\n    public  boolean  isDead ()  {\r\n         return Dead;\r\n    }\r\n\r\n    public  void  setDead ( boolean Dead)  {\r\n         this .dead = Dead;\r\n    }\r\n\r\n\r\n    public  Boss ()  {\r\n    }\r\n\r\n    public String getName ()  {\r\n         return name;\r\n    }\r\n\r\n    public  void  setName (String name)  {\r\n         this .name = name;\r\n    }\r\n\r\n    public ArrayList <String> getEquipment ()  {\r\n         return Equipment;\r\n    }\r\n\r\n    public  void  setEquipment (ArrayList <String> Equipment)  {\r\n         this .equipment = Equipment;\r\n    }\r\n}\r\nWOWHFB.java\r\n\r\n\r\nPackage com.hzj163.myhandler;\r\n\r\n\r\nImport java.util.ArrayList;\r\n\r\nWorld of Warcraft heroics // \r\npublic  class  WOWHFB  {\r\n     // Copy Name\r\n    String name;\r\n    // BOSS List\r\n    ArrayList <Boss> bosses;\r\n\r\n\r\n    public  WOWHFB (String name, ArrayList <Boss> Bosses)  {\r\n         this .name = name;\r\n         this .bosses = Bosses;\r\n    }\r\n\r\n    public  WOWHFB ()  {\r\n    }\r\n\r\n    public String getName ()  {\r\n         return name;\r\n    }\r\n\r\n    public  void  setName (String name)  {\r\n         this .name = name;\r\n    }\r\n\r\n    public ArrayList <Boss> getBosses ()  {\r\n         return Bosses;\r\n    }\r\n\r\n    public  void  setBosses (ArrayList <Boss> Bosses)  {\r\n         this .bosses = Bosses;\r\n    }\r\n}\r\nOtherActivity.java\r\n\r\n\r\n\r\nPackage com.hzj163.myhandler;\r\n Import android.os.Handler;\r\n Import android.support.v7.app.AppCompatActivity;\r\n Import android.os.Bundle;\r\n Import android.view.View;\r\n Import android.widget.Button;\r\n Import android.widget .TextView;\r\n Import java.util.ArrayList;\r\n Import java.util.HashSet;\r\n Import java.util.Random;\r\n\r\n// Here To demonstrate ThreadLocal, so do not do any package \r\npublic  class  OtherActivity  extends  AppCompatActivity  {\r\n\r\n    // Copy the object\r\n    WOWHFB wowhfb;\r\n    TextView textView1;\r\n    TextView textView2;\r\n    TextView textView3;\r\n    HandlerMain handler = new Handler ();\r\n    Button button1;\r\n\r\n    // Manage threads\r\n    HashSet hashSet;\r\n\r\n    // Synchronization lock \r\n    Object Object = new Object ();\r\n\r\n\r\n    // Initialize copy \r\n    public WOWHFB initWowhfb ()  {\r\n         // instantiate a copy of the object [ready to let three teams at the same time enter a copy cut BOSS] \r\n        WOWHFB wowhfb = new WOWHFB ();\r\n        wowhfb.setName ( \"Upper Blackrock Spire\" );\r\n\r\n        // Set BOSS \r\n        Boss BOSS1 = new Boss ();\r\n         // BOSS name \r\n        boss1.setName ( \"Warlord Zhayi La\" );\r\n         // falling equipment \r\n        ArrayList <String> equipment1 = new ArrayList ();\r\n        equipment1.add ( \"Shahram barren Sword\" );\r\n        equipment1.add ( \"Fel Shanker\" );\r\n        equipment1.add ( \"ember scales Talisman\" );\r\n        equipment1.add ( \"Mystery Hood\" );\r\n        equipment1.add ( \"dye cream hood\" );\r\n        equipment1.add ( \"streamer Hood\" );\r\n        equipment1.add ( \"tied Light's mask\" );\r\n         // set equipment\r\n        boss1.setEquipment (equipment1);\r\n        // Set the boss whether death \r\n        boss1.setDead ( false );\r\n\r\n        Boss boss2 = new Boss ();\r\n        boss2.setName ( \"Wild wing anger\" );\r\n        ArrayList <String> equipment2 = new ArrayList ();\r\n        equipment2.add ( \"Black Hand Destruction Halberd\" );\r\n        equipment2.add ( \"Wings of Fire tooth anger\" );\r\n        equipment2.add ( \"Blast collar\" );\r\n        equipment2.add ( \"Burning Blade collar\" );\r\n        equipment2.add ( \"cranial tooth necklace\" );\r\n        equipment2.add ( \"Indian style necklace\" );\r\n        equipment2.add ( \"Magister of the chain\" );\r\n        boss2.setEquipment (equipment2);\r\n        boss2.setDead ( false );\r\n\r\n        Boss boss3 = new Boss ();\r\n        boss3.setName ( \"Commander Sa Beike\" );\r\n        ArrayList <String> equipment3 = new ArrayList ();\r\n        equipment3.add ( \"Sa Beike evil sword\" );\r\n        equipment3.add ( \"Sa Beike savage sword\" );\r\n        equipment3.add ( \"Sa Beike lucky stone\" );\r\n        equipment3.add ( \"Mystery gloves\" );\r\n        equipment3.add ( \"dye cream gloves\" );\r\n        equipment3.add ( \"streamer gloves\" );\r\n        equipment3.add ( \"tied Gloves light\" );\r\n        boss3.setEquipment (equipment3);\r\n        boss3.setDead ( false );\r\n\r\n        Boss BOSS4 = new Boss ();\r\n        boss4.setName ( \"Qi Lake\" );\r\n        ArrayList <String> equipment4 = new ArrayList ();\r\n        equipment4.add ( \"Fink scalpel\" );\r\n        equipment4.add ( \"Qi Lake of evil blood potion\" );\r\n        equipment4.add ( \"Roger brown diamond signet ring\" );\r\n        equipment4.add ( \"Said co-Ming Ring\" );\r\n        equipment4.add ( \"Blood spine Ring\" );\r\n        boss4.setEquipment (equipment4);\r\n        boss4.setDead ( false );\r\n\r\n\r\n        Boss boss5 = new Boss ();\r\n        boss5.setName ( \"iron off by Al Gore Mountain\" );\r\n        ArrayList <String> equipment5 = new ArrayList ();\r\n        equipment5.add ( \"Sinopec hammer\" );\r\n        equipment5.add ( \"Union blade cloak\" );\r\n        equipment5.add ( \"Marksman cloak\" );\r\n        equipment5.add ( \"Violence harmony cloak\" );\r\n        equipment5.add ( \"evil bone cloak\" );\r\n        equipment5.add ( \"arcane cloak\" );\r\n        boss5.setEquipment (equipment5);\r\n        boss5.setDead ( false );\r\n\r\n\r\n        // Instantiate BOSS collection \r\n        ArrayList <Boss> Bosses = new ArrayList ();\r\n        bosses.add (boss1);\r\n        bosses.add (boss2);\r\n        bosses.add (boss3);\r\n        bosses.add (boss4);\r\n        bosses.add (boss5);\r\n        // Set Boss collection\r\n        wowhfb.setBosses (bosses);\r\n\r\n        return wowhfb;\r\n    }\r\n\r\n    Override \r\n    protected  void  onCreate (Bundle savedInstanceState)  {\r\n         Super .onCreate (savedInstanceState);\r\n        setContentView (R.layout.activity_other);\r\n        . getSupportActionBar () setTitle ( \"Upper Blackrock Spire\" );\r\n\r\n        textView1 = (TextView) findViewById (R.id.textView1);\r\n        textView2 = (TextView) findViewById (R.id.textView2);\r\n        textView3 = (TextView) findViewById (R.id.textView3);\r\n        button1 = (Button) findViewById (R.id.button1);\r\n        // Is responsible for monitoring all the threads end \r\n        hashset = new HashSet ();\r\n         // copy of the object is instantiated\r\n        wowhfb = initWowhfb ();\r\n\r\n    }\r\n\r\n    // Thread 1 \r\n    Runnable runnable1 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n             // Add a collection management thread [need to be synchronized, that is multiple threads share a collection} \r\n            synchronized (Object) {\r\n                hashSet.add ( this );\r\n            }\r\n            // Start the copy, using ThreadLocal isolation WOWHFB objects \r\n            ThreadLocal <WOWHFB> threadLocal = new ThreadLocal () {\r\n                 // initialization copy \r\n                Override \r\n                protected Object initialValue ()  {\r\n                     return wowhfb;\r\n                }\r\n            };\r\n\r\n            // Fight ...... \r\n            handlerMain.post ( new Runnable () {\r\n                 Override \r\n                public  void  run ()  {\r\n                    textView1.setText ( \"1 start fighting team\" );\r\n                }\r\n            });\r\n            try {\r\n                Thread.sleep ( ten thousand );\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace ();\r\n            }\r\n            // End the fighting Usage threadLocal.get () took a copy of the object]\r\n            WOWHFB temp = threadLocal.get ();\r\n            // Killed two BOSS \r\n            temp.getBosses () get (. 0 ) .setDead ( true );\r\n            . temp.getBosses () get ( 1 ) .setDead ( true );\r\n             // Trophy \r\n            ArrayList <String> result = new ArrayList ();\r\n             // get equipment \r\n            Random random = new Random ();\r\n             // random get equipment \r\n            int randomTemp1 = random.nextInt (temp.getBosses () get (. 0 ) .getEquipment () size ().);\r\n             int randomTemp2 = random.nextInt (. temp.getBosses () get ( 1 .) .getEquipment () size ()) ;\r\n            result.add (. temp.getBosses () get ( 0 .) .getEquipment () get (randomTemp1));\r\n            result.add (temp.getBosses () get (. 1 ) .getEquipment () get (randomTemp2).);\r\n             // gather information \r\n            Final StringBuffer stringBuffer = new StringBuffer ();\r\n            StringBuffer.append ( \"clan *** *** 1 kill BOSS\" );\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n             for ( int i = 0 ; i <temp.getBosses () size ();. i ++) {\r\n                 if . (temp.getBosses () get (i) .isDead () ) {\r\n                    stringBuffer.append (temp.getBosses () get (i) .getName ().);\r\n                    StringBuffer.append ( \"\\ r \\ N\" );\r\n                }\r\n            }\r\n            StringBuffer.append ( \"booty *** ***\" );\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n             for ( int i = 0 ; i <result.size (); i ++) {\r\n                stringBuffer.append (result.get (i));\r\n                StringBuffer.append ( \"\\ r \\ N\" );\r\n            }\r\n\r\n            Thread {// Add a collection management need to be synchronized, that is multiple threads share a collection} \r\n            synchronized (Object) {\r\n                hashSet.remove ( this );\r\n            }\r\n            // Display the trophy \r\n            handlerMain.post ( new Runnable () {\r\n                 Override \r\n                public  void  run ()  {\r\n                    textView1.setText (stringBuffer.toString ());\r\n\r\n                    // Determine whether all threads end \r\n                    if (hashSet.isEmpty ()) {\r\n                        button1.setEnabled ( true );\r\n\r\n                        // Here we must note that the ThreadLocal object does not clone program to clone multiple copies of an object \r\n                        // copy of the object is actually still is one, so after the end of all threads, you need to reset the copy of the object\r\n                        wowhfb = initWowhfb ();\r\n\r\n\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n    Thread 2 // \r\n    Runnable runnable2 = new Runnable () {\r\n\r\n        Override \r\n        public  void  run ()  {\r\n\r\n            synchronized (Object) {\r\n                hashSet.add ( this );\r\n            }\r\n\r\n            // Start the copy, using ThreadLocal isolation WOWHFB objects \r\n            ThreadLocal <WOWHFB> threadLocal = new ThreadLocal () {\r\n                 // initialization copy \r\n                Override \r\n                protected Object initialValue ()  {\r\n                     return wowhfb;\r\n                }\r\n            };\r\n\r\n            handlerMain.post ( new Runnable () {\r\n                 Override \r\n                public  void  run ()  {\r\n                    textView2.setText ( \"clan began fighting 2\" );\r\n                }\r\n            });\r\n            // Fight ...... \r\n            try {\r\n                Thread.sleep ( 5000 );\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace ();\r\n            }\r\n            // End fighting\r\n            WOWHFB temp = threadLocal.get ();\r\n            // Killed two BOSS \r\n            temp.getBosses () get (. 0 ) .setDead ( true );\r\n             // Trophy \r\n            ArrayList <String> result = new ArrayList ();\r\n             // get equipment \r\n            Random random = new Random ();\r\n             // random get equipment \r\n            int randomTemp1 = random.nextInt (temp.getBosses () get (. 0 ) .getEquipment () size ().);\r\n            result.add (. temp.getBosses () get ( 0 .) .getEquipment () get (randomTemp1));\r\n\r\n\r\n            // Gathering information \r\n            Final StringBuffer stringBuffer = new StringBuffer ();\r\n            StringBuffer.append ( \"clan *** 2 *** BOSS kill\" );\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n             for ( int i = 0 ; i <temp.getBosses () size ();. i ++) {\r\n                 if . (temp.getBosses () get (i) .isDead () ) {\r\n                    stringBuffer.append (temp.getBosses () get (i) .getName ().);\r\n                    StringBuffer.append ( \"\\ r \\ N\" );\r\n                }\r\n            }\r\n            StringBuffer.append ( \"booty *** ***\" );\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n             for ( int i = 0 ; i <result.size (); i ++) {\r\n                stringBuffer.append (result.get (i));\r\n                StringBuffer.append ( \"\\ r \\ N\" );\r\n            }\r\n\r\n\r\n            synchronized (Object) {\r\n                hashSet.remove ( this );\r\n            }\r\n\r\n            // Display the trophy \r\n            handlerMain.post ( new Runnable () {\r\n                 Override \r\n                public  void  run ()  {\r\n                    textView2.setText (stringBuffer.toString ());\r\n\r\n                    // Determine whether all threads end \r\n                    if (hashSet.isEmpty ()) {\r\n                        button1.setEnabled ( true );\r\n                        wowhfb = initWowhfb ();\r\n                    }\r\n\r\n                }\r\n            });\r\n\r\n\r\n        }\r\n    };\r\n\r\n    // Thread 3 \r\n    Runnable runnable3 = new Runnable () {\r\n\r\n        Override \r\n        public  void  run ()  {\r\n\r\n            synchronized (Object) {\r\n                hashSet.add ( this );\r\n            }\r\n\r\n\r\n            // Start the copy, using ThreadLocal isolation WOWHFB objects \r\n            ThreadLocal <WOWHFB> threadLocal = new ThreadLocal () {\r\n                 // initialization copy \r\n                Override \r\n                protected Object initialValue ()  {\r\n                     return wowhfb;\r\n                }\r\n            };\r\n\r\n            handlerMain.post ( new Runnable () {\r\n                 Override \r\n                public  void  run ()  {\r\n                    textView3.setText ( \"clan fighting began 3\" );\r\n                }\r\n            });\r\n\r\n            // Fight ...... \r\n            try {\r\n                Thread.sleep ( 20,000 );\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace ();\r\n            }\r\n            // End fighting\r\n            WOWHFB temp = threadLocal.get ();\r\n            // Killed two BOSS \r\n            temp.getBosses () get (. 0 ) .setDead ( true );\r\n            . temp.getBosses () get ( 1 ) .setDead ( true );\r\n            . temp.getBosses () get ( 2 ) .setDead ( true );\r\n            . temp.getBosses () get ( 3 ) .setDead ( true );\r\n            . temp.getBosses () get ( 4 ) .setDead ( true );\r\n\r\n            // Trophy \r\n            ArrayList <String> result = new ArrayList ();\r\n             // get equipment \r\n            Random random = new Random ();\r\n             // random get equipment \r\n            int randomTemp1 = random.nextInt (temp.getBosses () get (. 0 ) .getEquipment () .size ());\r\n\r\n            int randomTemp2 = random.nextInt (. temp.getBosses () get ( 1 .) .getEquipment () size ());\r\n\r\n            int randomTemp3 = random.nextInt (. temp.getBosses () get ( 2 .) .getEquipment () size ());\r\n\r\n            int randomTemp4 = random.nextInt (temp.getBosses () get (. 3 ) .getEquipment () size ().);\r\n\r\n            int randomTemp5 = random.nextInt (temp.getBosses () get (. 4 ) .getEquipment () size ().);\r\n\r\n            result.add (. temp.getBosses () get ( 0 .) .getEquipment () get (randomTemp1));\r\n            result.add (. temp.getBosses () get ( 1 ) .getEquipment () get (randomTemp2).);\r\n            result.add (. temp.getBosses () get ( 2 ) .getEquipment () get (randomTemp3).);\r\n            result.add (. temp.getBosses () get ( 3 ) .getEquipment () get (randomTemp4).);\r\n            result.add (. temp.getBosses () get ( 4 ) .getEquipment () get (randomTemp5).);\r\n\r\n\r\n            // Gathering information \r\n            Final StringBuffer stringBuffer = new StringBuffer ();\r\n            StringBuffer.append ( \"clan *** *** 3 killed BOSS\" );\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n             for ( int i = 0 ; i <temp.getBosses () size ();. i ++) {\r\n                 if . (temp.getBosses () get (i) .isDead () ) {\r\n                    stringBuffer.append (temp.getBosses () get (i) .getName ().);\r\n                    StringBuffer.append ( \"\\ r \\ N\" );\r\n                }\r\n            }\r\n            StringBuffer.append ( \"booty *** ***\" );\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n             for ( int i = 0 ; i <result.size (); i ++) {\r\n                stringBuffer.append (result.get (i));\r\n                StringBuffer.append ( \"\\ r \\ N\" );\r\n            }\r\n\r\n\r\n            synchronized (Object) {\r\n                hashSet.remove ( this );\r\n            }\r\n\r\n\r\n            // Display the trophy \r\n            handlerMain.post ( new Runnable () {\r\n                 Override \r\n                public  void  run ()  {\r\n                    textView3.setText (stringBuffer.toString ());\r\n                    // Determine whether all threads end \r\n                    if (hashSet.isEmpty ()) {\r\n                        button1.setEnabled ( true );\r\n                        wowhfb = initWowhfb ();\r\n\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n\r\n    public  void  btn1 (View View)  {\r\n\r\n        new Thread (runnable1) .start ();\r\n         new Thread (runnable2) .start ();\r\n         new Thread (runnable3) .start ();\r\n        button1.setEnabled ( false );\r\n    }\r\n\r\n}\r\n[Package version, beans unchanged]\r\n\r\n\r\nPackage com.hzj163.myhandler;\r\n\r\nImport android.os.Handler;\r\n Import android.os.Message;\r\n Import android.support.v7.app.AppCompatActivity;\r\n Import android.os.Bundle;\r\n Import android.view.Menu;\r\n Import android.view.MenuItem;\r\n Import android.view .view;\r\n Import android.widget.Button;\r\n Import android.widget.Switch;\r\n Import android.widget.TextView;\r\n\r\nImport java.lang.ref.WeakReference;\r\n Import java.util.ArrayList;\r\n Import java.util.HashSet;\r\n Import java.util.Random;\r\n\r\n\r\n// Packaged version \r\npublic  class  OtherActivity1  extends  AppCompatActivity  {\r\n     // 1 team began \r\n    public  static  Final  int START_1 = 1 ;\r\n     // 2 clan began \r\n    public  static  Final  int START_2 = 2 ;\r\n     // 3 team began \r\n    public  static  Final  int START_3 = 3 ;\r\n     / / 1 team ended \r\n    public  static  Final  int END_1 = 4 ;\r\n     // 2 teams end \r\n    public  static  Final  int END_2 = 5 ;\r\n     // 3 team ended \r\n    public  static  Final  int END_3 = 6 ;\r\n\r\n\r\n    // Copy the object\r\n    WOWHFB wowhfb;\r\n    TextView textView1;\r\n    TextView textView2;\r\n    TextView textView3;\r\n\r\n\r\n    Button button1;\r\n    // Manage threads\r\n    HashSet hashSet;\r\n    // Synchronization lock \r\n    Object Object = new Object ();\r\n\r\n\r\n    Override \r\n    protected  void  onCreate (Bundle savedInstanceState)  {\r\n         Super .onCreate (savedInstanceState);\r\n        setContentView (R.layout.activity_other);\r\n        . getSupportActionBar () setTitle ( \"Upper Blackrock Spire\" );\r\n        textView1 = (TextView) findViewById (R.id.textView1);\r\n        textView2 = (TextView) findViewById (R.id.textView2);\r\n        textView3 = (TextView) findViewById (R.id.textView3);\r\n        button1 = (Button) findViewById (R.id.button1);\r\n        // Is responsible for monitoring all the threads end \r\n        hashset = new HashSet ();\r\n        wowhfb = initWowhfb ();\r\n\r\n    }\r\n\r\n\r\n    // Main thread handler \r\n    MyHandler handlerMain = new MyHandler ( new WeakReference <OtherActivity1> (OtherActivity1. this ));\r\n\r\n    static  class  MyHandler  extends  Handler  {\r\n        WeakReference <OtherActivity1> weakReference;\r\n\r\n        public  MyHandler (WeakReference <OtherActivity1> WeakReference)  {\r\n             this .weakReference = WeakReference;\r\n        }\r\n\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n            OtherActivity1 temp = weakReference.get ();\r\n            switch (msg.what) {\r\n                 Case START_1:\r\n                    temp.textView1.setText ( \"1 start fighting team\" );\r\n                     break ;\r\n                 Case START_2:\r\n                    temp.textView2.setText ( \"clan began fighting 2\" );\r\n                     break ;\r\n                 Case START_3:\r\n                    temp.textView3.setText ( \"clan fighting began 3\" );\r\n                     break ;\r\n                 Case END_1:\r\n                    temp.textView1.setText (msg.obj.toString ());\r\n                    temp.reFB ();\r\n                    break ;\r\n                 Case END_2:\r\n                    temp.textView2.setText (msg.obj.toString ());\r\n                    temp.reFB ();\r\n                    break ;\r\n                 Case END_3:\r\n                    temp.textView3.setText (msg.obj.toString ());\r\n                    temp.reFB ();\r\n                    break ;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    // Initialize copy \r\n    public WOWHFB initWowhfb ()  {\r\n         // instantiate a copy of the object [ready to let three teams at the same time enter a copy cut BOSS] \r\n        WOWHFB wowhfb = new WOWHFB ();\r\n        wowhfb.setName ( \"Upper Blackrock Spire\" );\r\n\r\n        // Set BOSS \r\n        Boss BOSS1 = new Boss ();\r\n         // BOSS name \r\n        boss1.setName ( \"Warlord Zhayi La\" );\r\n         // falling equipment \r\n        ArrayList <String> equipment1 = new ArrayList ();\r\n        equipment1.add ( \"Shahram barren Sword\" );\r\n        equipment1.add ( \"Fel Shanker\" );\r\n        equipment1.add ( \"ember scales Talisman\" );\r\n        equipment1.add ( \"Mystery Hood\" );\r\n        equipment1.add ( \"dye cream hood\" );\r\n        equipment1.add ( \"streamer Hood\" );\r\n        equipment1.add ( \"tied Light's mask\" );\r\n         // set equipment\r\n        boss1.setEquipment (equipment1);\r\n        // Set the boss whether death \r\n        boss1.setDead ( false );\r\n\r\n        Boss boss2 = new Boss ();\r\n        boss2.setName ( \"Wild wing anger\" );\r\n        ArrayList <String> equipment2 = new ArrayList ();\r\n        equipment2.add ( \"Black Hand Destruction Halberd\" );\r\n        equipment2.add ( \"Wings of Fire tooth anger\" );\r\n        equipment2.add ( \"Blast collar\" );\r\n        equipment2.add ( \"Burning Blade collar\" );\r\n        equipment2.add ( \"cranial tooth necklace\" );\r\n        equipment2.add ( \"Indian style necklace\" );\r\n        equipment2.add ( \"Magister of the chain\" );\r\n        boss2.setEquipment (equipment2);\r\n        boss2.setDead ( false );\r\n\r\n        Boss boss3 = new Boss ();\r\n        boss3.setName ( \"Commander Sa Beike\" );\r\n        ArrayList <String> equipment3 = new ArrayList ();\r\n        equipment3.add ( \"Sa Beike evil sword\" );\r\n        equipment3.add ( \"Sa Beike savage sword\" );\r\n        equipment3.add ( \"Sa Beike lucky stone\" );\r\n        equipment3.add ( \"Mystery gloves\" );\r\n        equipment3.add ( \"dye cream gloves\" );\r\n        equipment3.add ( \"streamer gloves\" );\r\n        equipment3.add ( \"tied Gloves light\" );\r\n        boss3.setEquipment (equipment3);\r\n        boss3.setDead ( false );\r\n\r\n        Boss BOSS4 = new Boss ();\r\n        boss4.setName ( \"Qi Lake\" );\r\n        ArrayList <String> equipment4 = new ArrayList ();\r\n        equipment4.add ( \"Fink scalpel\" );\r\n        equipment4.add ( \"Qi Lake of evil blood potion\" );\r\n        equipment4.add ( \"Roger brown diamond signet ring\" );\r\n        equipment4.add ( \"Said co-Ming Ring\" );\r\n        equipment4.add ( \"Blood spine Ring\" );\r\n        boss4.setEquipment (equipment4);\r\n        boss4.setDead ( false );\r\n\r\n\r\n        Boss boss5 = new Boss ();\r\n        boss5.setName ( \"iron off by Al Gore Mountain\" );\r\n        ArrayList <String> equipment5 = new ArrayList ();\r\n        equipment5.add ( \"Sinopec hammer\" );\r\n        equipment5.add ( \"Union blade cloak\" );\r\n        equipment5.add ( \"Marksman cloak\" );\r\n        equipment5.add ( \"Violence harmony cloak\" );\r\n        equipment5.add ( \"evil bone cloak\" );\r\n        equipment5.add ( \"arcane cloak\" );\r\n        boss5.setEquipment (equipment5);\r\n        boss5.setDead ( false );\r\n\r\n\r\n        // Instantiate BOSS collection \r\n        ArrayList <Boss> Bosses = new ArrayList ();\r\n        bosses.add (boss1);\r\n        bosses.add (boss2);\r\n        bosses.add (boss3);\r\n        bosses.add (boss4);\r\n        bosses.add (boss5);\r\n        // Set Boss collection\r\n        wowhfb.setBosses (bosses);\r\n\r\n        return wowhfb;\r\n    }\r\n\r\n\r\n    // Fighting process \r\n    public  void  startFB ( int massageStartWhat, int massageEndWhat, int sleep)  {\r\n         // random number ready \r\n        Random random = new Random ();\r\n         // add collection management thread [need to be synchronized, that is multiple threads share a collection] \r\n        synchronized (Object) {\r\n            hashSet.add ( this );\r\n        }\r\n        // Start the copy, using ThreadLocal isolation WOWHFB objects \r\n        ThreadLocal <WOWHFB> threadLocal = new ThreadLocal () {\r\n             // initialization copy \r\n            Override \r\n            protected Object initialValue ()  {\r\n                 return wowhfb;\r\n            }\r\n        };\r\n        // Send the battle ...... message\r\n        Message messageStart = handlerMain.obtainMessage ();\r\n        messageStart.what = massageStartWhat;\r\n        messageStart.sendToTarget ();\r\n        try {\r\n            Thread.sleep (sleep);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace ();\r\n        }\r\n        // End the fighting Usage threadLocal.get () took a copy of the object]\r\n        WOWHFB temp = threadLocal.get ();\r\n        // Kill the N-boss [Random] \r\n        int bossDead = random.nextInt (temp.getBosses () size () -. 1 );\r\n        bossDead ++;\r\n        // Trophy \r\n        ArrayList <String> result = new ArrayList ();\r\n         for ( int i = 0 ; i <bossDead; i ++) {\r\n            temp.getBosses () get (i) .setDead (. true );\r\n             // random get equipment \r\n            int randomTempIndex = random.nextInt (temp.getBosses () get (i) .getEquipment () size ()..);\r\n            result.add (. temp.getBosses () get (i) .getEquipment () get (randomTempIndex).);\r\n        }\r\n        // Gathering information \r\n        Final StringBuffer stringBuffer = new StringBuffer ();\r\n         // judge clan \r\n        switch (massageStartWhat) {\r\n             Case START_1:\r\n                StringBuffer.append ( \"clan *** *** 1 kill BOSS\" );\r\n                 break ;\r\n             Case START_2:\r\n                StringBuffer.append ( \"clan *** 2 *** BOSS kill\" );\r\n                 break ;\r\n             Case START_3:\r\n                StringBuffer.append ( \"clan *** *** 3 killed BOSS\" );\r\n                 break ;\r\n        }\r\n        StringBuffer.append ( \"\\ r \\ N\" );\r\n\r\n        // Collected killed Boss name \r\n        for ( int i = 0 ; i <temp.getBosses () size ();. i ++) {\r\n             if (. temp.getBosses () get (i) .isDead ()) {\r\n                stringBuffer.append (temp.getBosses () get (i) .getName ().);\r\n                StringBuffer.append ( \"\\ r \\ N\" );\r\n            }\r\n        }\r\n        // Kill the Boss collection equipment \r\n        StringBuffer.append ( \"booty *** ***\" );\r\n        StringBuffer.append ( \"\\ r \\ N\" );\r\n         for ( int i = 0 ; i <result.size (); i ++) {\r\n            stringBuffer.append (result.get (i));\r\n            StringBuffer.append ( \"\\ r \\ N\" );\r\n        }\r\n        Thread {// Add a collection management need to be synchronized, that is multiple threads share a collection} \r\n        synchronized (Object) {\r\n            hashSet.remove ( this );\r\n        }\r\n        // Send the fighting ended message\r\n        Message messageEnd = handlerMain.obtainMessage ();\r\n        messageEnd.what = massageEndWhat;\r\n        messageEnd.obj = stringBuffer;\r\n        messageEnd.sendToTarget ();\r\n    }\r\n    // Reset The copy \r\n    public  void  REFB ()  {\r\n         // determine whether all the threads end \r\n        if (hashSet.isEmpty ()) {\r\n            button1.setEnabled ( true );\r\n             // Here we must note that the ThreadLocal object does not clone program to clone multiple copies of an object \r\n            // copy of the object is actually still is one, so after the end of all threads, you need to reset the copy of the object\r\n            wowhfb = initWowhfb ();\r\n        }\r\n    }\r\n\r\n\r\n    Team 1 // \r\n    Runnable runnable1 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n\r\n            startFB (START_1, END_1, new Random () nextInt (. five thousand ) + eight thousand );\r\n        }\r\n    };\r\n\r\n    Team 2 // \r\n    Runnable runnable2 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            startFB (START_2, END_2, new Random () nextInt (. five thousand ) + eight thousand );\r\n\r\n        }\r\n    };\r\n\r\n    // Clan 3 \r\n    Runnable runnable3 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            startFB (START_3, END_3, new Random () nextInt (. five thousand ) + eight thousand );\r\n        }\r\n    };\r\n\r\n    public  void  btn1 (View View)  {\r\n\r\n        // Start \r\n        new Thread (runnable1) .start ();\r\n         new Thread (runnable2) .start ();\r\n         new Thread (runnable3) .start ();\r\n        button1.setEnabled ( false );\r\n    }\r\n\r\n\r\n    Override \r\n    public  boolean  onCreateOptionsMenu (Menu menu)  {\r\n         // Inflate the menu; this adds items to the Action Bar if it is Present.\r\n        . getMenuInflater () inflate (R.menu.menu_other_activity1, menu);\r\n        return  true ;\r\n    }\r\n\r\n    Override \r\n    public  boolean  onOptionsItemSelected (MenuItem Item)  {\r\n         // Handle Bar Action Item Clicks here. The Action Bar Will \r\n        // Automatically handle Clicks on the Home / Up button, so Long \r\n        as you // Specify a parent Activity in AndroidManifest.xml. \r\n        int ID = item.getItemId ();\r\n\r\n        // Noinspection SimplifiableIfStatement \r\n        if (ID == R.id.action_settings) {\r\n             return  true ;\r\n        }\r\n\r\n        return  Super .onOptionsItemSelected (Item);\r\n    }\r\n}\r\n\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nJAVA thread pool [ExecutorService]\r\nThread pool functions:\r\n\r\n  Thread pool function is to limit the number of system execution threads.\r\n\r\n  According to the environmental situation of the system, you can automatically or manually set the number of threads, to achieve the best results run; less waste system resources, cause the system more crowded inefficient. Control the number of threads with the thread pool, other threads waiting in line. Tasks A task is finished, and then take from the queue in front of the start of execution. If the queue does not wait for the process, the resources of the thread pool is waiting. When a new task needs to be run, if the thread pool worker threads have to wait, you can start running; otherwise enter the queue.\r\n\r\nWhy use a thread pool:\r\n\r\nReduce the number of creating and destroying threads, each worker thread can be reused, perform multiple tasks.\r\n\r\nAccording to the capacity of the system, adjust the number of thread pool threads work line to prevent because consuming too much memory, and the server so tired (each thread needs about 1MB of memory, the thread open, the more memory consumption also the greater the last crash).\r\n\r\nJAVA inside thread pool\r\n\r\n\r\n\r\n  Top-level interface Java inside the thread pool is Executor, but is not a strict sense Executor thread pools, but only one thread of execution tool. The real thread pool interface ExecutorService.\r\n\r\n  Java offers four thread pool by Executors, respectively:\r\n\r\nnewCachedThreadPool create a cached thread pool. If the size of the thread pool exceeds the thread processing tasks required, it will idle recovery section (60 seconds does not perform the task) threads, while increasing the number of tasks, this thread pool and you can add a new thread to handle intelligent tasks. This thread pool thread pool size do not limit the size of the thread pool thread is entirely dependent on the maximum size of the operating system (or JVM) that can be created.\r\n\r\nnewFixedThreadPool create fixed-size thread pool. Each time you submit a task to create a thread, until the thread reaches the maximum size of the thread pool. Once the size of the thread pool reaches the maximum will remain unchanged, because if a thread end execution exception, the thread pool will add a new thread.\r\n\r\nnewScheduledThreadPool create a thread pool size unlimited. This thread pool to support timing and demand periodically perform a task.\r\n\r\nnewSingleThreadExecutor create a single-threaded thread pool. This thread pool is only one thread at work, which is equivalent to a single-threaded serial execution of all tasks. If this unique thread because abnormal end, then there will be a new thread to replace it. This thread pool to ensure the implementation of all tasks in accordance with the order submitted by the task sequence.\r\n\r\nCreating a Thread Pool\r\n\r\nExecutor interface\r\nExecutorService Interface\r\nExecutors class static method to configure the thread pool\r\nCase\r\n\r\n\r\nPackage com.hzj163.myexecutorservice;\r\n Import android.os.Handler;\r\n Import android.os.Message;\r\n Import android.support.v7.app.AppCompatActivity;\r\n Import android.os.Bundle;\r\n Import android.view.View;\r\n Import android.widget .TextView;\r\n Import java.lang.ref.WeakReference;\r\n Import java.util.concurrent.ExecutorService;\r\n Import java.util.concurrent.Executors;\r\n Import java.util.concurrent.ScheduledExecutorService;\r\n Import java.util.concurrent.TimeUnit;\r\n public  class  MainActivity  extends  AppCompatActivity  {\r\n\r\n    TextView textView1;\r\n    TextView textView2;\r\n    TextView textView3;\r\n    TextView textView4;\r\n    TextView textView5;\r\n    TextView textView6;\r\n    TextView textView7;\r\n    TextView textView8;\r\n    TextView textView9;\r\n    TextView textView10;\r\n\r\n    protected  void  onCreate (Bundle savedInstanceState)  {\r\n         Super .onCreate (savedInstanceState);\r\n        setContentView (R.layout.activity_main);\r\n        textView1 = (TextView) findViewById (R.id.textView1);\r\n        textView2 = (TextView) findViewById (R.id.textView2);\r\n        textView3 = (TextView) findViewById (R.id.textView3);\r\n        textView4 = (TextView) findViewById (R.id.textView4);\r\n        textView5 = (TextView) findViewById (R.id.textView5);\r\n        textView6 = (TextView) findViewById (R.id.textView6);\r\n        textView7 = (TextView) findViewById (R.id.textView7);\r\n        textView8 = (TextView) findViewById (R.id.textView8);\r\n        textView9 = (TextView) findViewById (R.id.textView9);\r\n        textView10 = (TextView) findViewById (R.id.textView10);\r\n    }\r\n\r\n    // Messaging \r\n    MyHandler handler = new MyHandler ( new WeakReference <MainActivity> (MainActivity. this ));\r\n     static  class  MyHandler  extends  Handler  {\r\n        WeakReference <MainActivity> weakReference;\r\n\r\n        public  MyHandler (WeakReference <MainActivity> WeakReference)  {\r\n             this .weakReference = WeakReference;\r\n        }\r\n\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n            MainActivity temp = weakReference.get ();\r\n\r\n            switch (msg.what) {\r\n                 Case  1 :\r\n                    temp.textView1.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  2 :\r\n                    temp.textView2.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  3 :\r\n                    temp.textView3.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  4 :\r\n                    temp.textView4.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  5 :\r\n                    temp.textView5.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  6 :\r\n                    temp.textView6.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  7 :\r\n                    temp.textView7.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  8 :\r\n                    temp.textView8.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  9 :\r\n                    temp.textView9.setText (msg.obj.toString ());\r\n                    break ;\r\n                 Case  10 :\r\n                    temp.textView10.setText (msg.obj.toString ());\r\n                    break ;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Thread business \r\n    public  void  myServer ( int What)  {\r\n         for ( int i = 0 ; i < 10 ; i ++) {\r\n             try {\r\n                Thread.sleep ( 1000 );\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace ();\r\n            }\r\n            Message message = handler.obtainMessage ();\r\n            message.what = what;\r\n            message.obj = i;\r\n            message.sendToTarget ();\r\n        }\r\n    }\r\n\r\n    // No. 1 Thread \r\n    Runnable runnable1 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 1 );\r\n        }\r\n    };\r\n    No. // 2 thread \r\n    Runnable runnable2 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n\r\n            myServer ( 2 );\r\n        }\r\n    };\r\n    // The 3rd thread \r\n    Runnable runnable3 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 3 );\r\n        }\r\n    };\r\n\r\n    No. 4 threads // \r\n    Runnable runnable4 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 4 );\r\n        }\r\n    };\r\n\r\n    No. 5 thread // \r\n    Runnable runnable5 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 5 );\r\n        }\r\n    };\r\n    No. 6 // thread \r\n    Runnable runnable6 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 6 );\r\n        }\r\n    };\r\n    // 7 thread \r\n    Runnable runnable7 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 7 );\r\n        }\r\n    };\r\n    No. 8 threads // \r\n    Runnable runnable8 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 8 );\r\n        }\r\n    };\r\n    // 9 Thread \r\n    Runnable runnable9 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 9 );\r\n        }\r\n    };\r\n    No. // 10 thread \r\n    Runnable runnable10 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            myServer ( 10 );\r\n        }\r\n    };\r\n\r\n    // Open plan common thread \r\n    public  void  btn1 (View View)  {\r\n         new Thread (runnable1) .start ();\r\n         new Thread (runnable2) .start ();\r\n         new Thread (runnable3) .start ();\r\n         new Thread (runnable4). Start ();\r\n         new Thread (runnable5) .start ();\r\n         new Thread (runnable6) .start ();\r\n         new Thread (runnable7) .start ();\r\n         new Thread (runnable8) .start ();\r\n         new Thread (runnable9). Start ();\r\n         new Thread (runnable10) .start ();\r\n    }\r\n\r\n    // Create a single worker thread Executor, with unbounded queue to run this thread. \r\n    public  void  btn2 (View View)  {\r\n        threadExecute (Executors.newSingleThreadExecutor ());\r\n    }\r\n\r\n    // Create a reusable fixed number of threads the thread pool, shared unbounded queue, to run these threads. \r\n    public  void  btn3 (View View)  {\r\n        ExecutorService ExecutorService = Executors.newFixedThreadPool ( 4 );\r\n        threadExecute (executorService);\r\n    }\r\n    // Create a thread pool that creates new threads as needed, but at the time previously constructed threads available to reuse them \r\n    public  void  btn4 ​​(View View)  {\r\n        ExecutorService executorService = Executors.newCachedThreadPool ();\r\n        threadExecute (executorService);\r\n    }\r\n\r\n    // Create a thread pool that can schedule commands to run after a given delay, or to execute periodically. \r\n    public  void  btn5 (View View)  {\r\n        ScheduledExecutorService ExecutorService = Executors.newScheduledThreadPool ( 5 );\r\n        executorService.schedule (runnable1, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable2, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable3, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable4, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable5, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable6, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable7, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable8, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable9, 1000 , TimeUnit.MILLISECONDS);\r\n        executorService.schedule (runnable10, 1000 , TimeUnit.MILLISECONDS);\r\n    }\r\n\r\n\r\n    // Execute thread pool \r\n    public  void  threadExecute (ExecutorService ExecutorService)  {\r\n        executorService.execute (runnable1);\r\n        executorService.execute (runnable2);\r\n        executorService.execute (runnable3);\r\n        executorService.execute (runnable4);\r\n        executorService.execute (runnable5);\r\n        executorService.execute (runnable6);\r\n        executorService.execute (runnable7);\r\n        executorService.execute (runnable8);\r\n        executorService.execute (runnable9);\r\n        executorService.execute (runnable10);\r\n    }\r\n\r\n}\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nAndroid messaging\r\n  Android UI active as the main thread, can not exceed 5 seconds time-consuming task, and all ViewGroup View and can only run on the main UI thread. If View or ViewGroup run in the second thread will throw [Only the original thread that created a view hierarchy can touch its views], it will be to solve the communication problems between the thread and thread through message mechanism in android\r\n\r\nCommunication between threads and threads, android adopt messaging\r\n\r\nAndroid message mechanism consists of the following components:\r\n\r\nHandler\r\nMessage\r\nMessageQueue\r\nLooper\r\n\r\n\r\nHandler\r\n\r\n  What is the handler? handler played on MQ to add messages and process messages role (processing only messages issued by himself), MQ notify it to perform a task (sendMessage), and in their own time loop to perform the task (handleMessage), whole process is asynchronous. handler will be associated with the creation of a looper, default constructor method associated with the current thread looper, but it also can be set in.\r\n\r\n  handler must be associated with a loop thread can play a role, Android UI is associated with a main thread and thread Loop, but we custom-defined thread must open the Loop\r\n\r\nHandler has the following two important features:\r\n\r\nhandler can send messages in any thread, these messages will be added to the MQ associated.\r\n\r\n\r\nhandler is to process messages in the looper thread in which it is associated.\r\n\r\n\r\nSend Message Handler\r\n\r\n  With after handler, we can use post (Runnable), postAtTime (Runnable, long), postDelayed (Runnable, long), sendEmptyMessage (int), sendMessage (Message), sendMessageAtTime (Message, long) and sendMessageDelayed (Message, long ) The method sends MQ on the news. Just look at these API you may feel handler can send two messages, one is Runnable object, one is message object, which is intuitive to understand, but in fact issued last post Runnable objects are encapsulated into a message objects.\r\n\r\nsend a callback program needs to send a message [to receive news]\r\n\r\nsendMessage () Message sent immediately to the message queue\r\nsendMessageAtFrontOfQueue () Message immediately sent to the queue, and is on the front of the queue\r\nsendMessageAtTime () to set the time, to send the Message Queue\r\nsendMessageDelayed () after a delay of several milliseconds, send Message to the queue\r\npost program sends a message [direct binding handler current thread of execution, need Runnable objects]\r\n\r\npost () Message sent immediately to the message queue\r\npostAtFrontOfQueue () Message immediately sent to the queue, and is on the front of the queue\r\npostAtTime () to set the time, to send the Message Queue\r\npostDelayed () after a delay of several milliseconds, send Message to the queue\r\nActivity object has a method runOnUiThread () method is actually the handler's post\r\n\r\nCase\r\n\r\nsend the program to send a message, do not use the Message object encapsulates the message\r\n\r\n\r\n    // Handler object instantiation \r\n    Handler handler = new Handler ()\r\n    {\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n            Log.i ( \"HZJ\" , \"receive the message:\" + msg.what);\r\n        }\r\n    };\r\n    public  void  btn1 (View View)  {\r\n         // send messages using Message message encapsulation object does not display \r\n        handler.sendEmptyMessage ( 1 );\r\n    }\r\nsend the program to send a message, use the Message object encapsulates the message\r\n\r\n\r\n    // Handler object instantiation \r\n    Handler handler = new Handler ()\r\n    {\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n            Log.i ( \"HZJ\" , \"receive the message:\" + msg.what);\r\n            Log.i ( \"HZJ\" , \"arg1 receive the message:\" + msg.arg1);\r\n            Log.i ( \"HZJ\" , \"arg2 receive the message:\" + msg.arg2);\r\n        }\r\n    };\r\n    public  void  btn1 (View View)  {\r\n         // send the message, the message encapsulated objects using Message \r\n        Message message = new Message ();\r\n         // message type \r\n        message.what = 1 ;\r\n         // message can carry two simple integer data \r\n        // message Data 1 \r\n        message.arg1 = 111 ;\r\n         // message data 2 \r\n        message.arg2 = 222 ;\r\n         // send message\r\n        handler.sendMessage (message);\r\n    }\r\nsend the program to send a message, use the Message object encapsulates the message, and the message\r\n\r\n\r\n    // Handler object instantiation \r\n    Handler handler = new Handler ()\r\n    {\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n            Log.i ( \"HZJ\" , \"receive the message:\" + msg.what);\r\n            Log.i ( \"HZJ\" , \"arg1 receive the message:\" + msg.arg1);\r\n            Log.i ( \"HZJ\" , \"arg2 receive the message:\" + msg.arg2);\r\n        }\r\n    };\r\n    public  void  btn1 (View View)  {\r\n         // send a message, send a message using the Message object \r\n        // Message object acquired as handler.obtainMessage (); instead direct new, so that efficiency will be higher, saving memory resources\r\n        Message message = handler.obtainMessage ();\r\n        // Message type \r\n        message.what = 1 ;\r\n         // message can carry two simple integer data \r\n        // message data 1 \r\n        message.arg1 = 111 ;\r\n         // message data 2 \r\n        message.arg2 = 222 ;\r\n         // send messages, where the use the sendToTarget message object (); method\r\n        message.sendToTarget ();\r\n    }\r\npost program sends a message\r\n\r\n\r\npublic  class  F4  extends  Fragment  {\r\n    Button button1;\r\n    View view;\r\n    public  F4 ()  {\r\n\r\n    }\r\n    // Second thread \r\n    Runnable Runnable = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n             // Since the runnable object using handler.post (Runnable); \r\n            // Also, because the main thread UI handler created \r\n            // therefore runnable object run method executes in the main thread UI \r\n            Log.i ( \"HZJ\" , Thread.currentThread () getName () +. \"-----\" );\r\n        }\r\n    };\r\n    // Handler object instantiation \r\n    Handler handler = new Handler ()\r\n    {\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n             // Note the use handler.post way, here for less than a message\r\n        }\r\n    };\r\n    public  void  btn1 (View View)  {\r\n         // send the message \r\n        // post series to send a message directly to the object will execute runnable threads directly in the handler object is located inside the run method \r\n        // so here post of runnable objects inside the run method is actually in Inside the main UI thread execution \r\n        // Here it does not need to use the callback method to get the message object handleMessage also get less\r\n        handler.post (runnable);\r\n    }\r\n\r\n    Override \r\n    public View onCreateView (LayoutInflater inflater, ViewGroup Container,\r\n                             Bundle savedInstanceState)  {\r\n\r\n        if (View == null ) {\r\n            View = Inflater.inflate (R.layout.fragment_f4, Container, false );\r\n            button1 = (Button) view.findViewById (R.id.button1);\r\n            button1.setOnClickListener ( new View.OnClickListener () {\r\n                 Override \r\n                public  void  onClick (View v)  {\r\n                    btn1 (v);\r\n                }\r\n            });\r\n\r\n        }\r\n        return View;\r\n    }\r\n\r\n\r\n}\r\nMessage Handler Processing\r\n\r\n  Process messages via callback handleMessage (Message msg) complete, of course, send the program needs to be used to send messages to the callback handler\r\n\r\n\r\n    // Handler object starts waiting for news \r\n    Handler handler = new Handler () {\r\n         Override \r\n        public  void  handleMessage (Message msg)  {\r\n             // receive a message to change the UI\r\n            textView1.setText (msg.obj.toString ());\r\n        }\r\n    };\r\nSecondary thread creating Handler objects\r\n\r\n\r\nPackage com.hzj163.mythread;\r\n Import android.os.Handler;\r\n Import android.os.Looper;\r\n\r\npublic  class  Thread1  implements  Runnable  {\r\n\r\n    Handler handler;\r\n    Override \r\n    public  void  run ()  {\r\n         // Looper ready\r\n        Looper.prepare ();\r\n        // Instantiate secondary thread Handler object, you must open Looper \r\n        // main examples of UI Handler objects do not need to open Looper, because the main thread UI and opened Looper \r\n        handler = new Handler ();\r\n         // Looper cycle\r\n        Looper.loop ();\r\n    }\r\n}\r\nAdt20 update to developers who might find such a warning on the handler: This Handler class should be static or leaks might occur.\r\n\r\n  First ADT 20 Changes we can find such a change: New Lint Checks: Look for handler leaks: This check makes sure that a handler inner class does not hold an implicit reference to its outer class.\r\n\r\n  Translation is, Lint will add a check items namely: to ensure that the internal handler class does not contain an implicit reference to the outer class. Share a handler under a looper thread objects, the message handler retained for reference, as long as there is a message in the queue, then the handler can not be recovered, if handler is not static then use the Handler of Service and Activity will also not be recovered . This may lead to memory leaks. Of course, this usually does not happen unless you send a long message delays.\r\n\r\n  The official recommended to static class handler, and use weak references inside WeakReference\r\n\r\nCase\r\n\r\n\r\nPackage com.hzj163.mythread;\r\n Import android.os.Bundle;\r\n Import android.os.Handler;\r\n Import android.os.Message;\r\n Import android.support.v4.app.Fragment;\r\n Import android.view.LayoutInflater;\r\n Import android.view .view;\r\n Import android.view.ViewGroup;\r\n Import android.widget.Button;\r\n Import java.lang.ref.WeakReference;\r\n\r\npublic  class  F4  extends  Fragment  {\r\n    Button button1;\r\n    View view;\r\n    public  F4 ()  {\r\n    }\r\n    // Handler object static inner class \r\n    static  class  MyHandler  extends  Handler  {\r\n         // use weak references refer to external class\r\n        WeakReference <F4> weakReference;\r\n\r\n        // Obtain an instance by constructing \r\n        public  MyHandler (WeakReference <F4> WeakReference)  {\r\n             this .weakReference = WeakReference;\r\n        }\r\n        Override \r\n        public  void  handleMessage (Message msg)  {\r\n             // update the main UI components \r\n            using a weak reference object // get method to get the external object\r\n            F4 temp = weakReference.get ();\r\n            temp.button1.setText ( \"xxxx\" );\r\n        }\r\n    }\r\n    // Handler object instantiation \r\n    MyHandler handler = new MyHandler ( new WeakReference <F4> ( this ));\r\n     // message \r\n    public  void  btn1 (View View)  {\r\n        Message message = handler.obtainMessage ();\r\n        message.sendToTarget ();\r\n    }\r\n\r\n    Override \r\n    public View onCreateView (LayoutInflater inflater, ViewGroup Container,\r\n                             Bundle savedInstanceState)  {\r\n\r\n        if (View == null ) {\r\n            View = Inflater.inflate (R.layout.fragment_f4, Container, false );\r\n            button1 = (Button) view.findViewById (R.id.button1);\r\n            button1.setOnClickListener ( new View.OnClickListener () {\r\n                 Override \r\n                public  void  onClick (View v)  {\r\n                    btn1 (v);\r\n                }\r\n            });\r\n        }\r\n        return View;\r\n    }\r\n\r\n\r\n}\r\nMessage\r\n\r\n  In the entire message processing mechanism, message called task, encapsulates the information and handler task treating the task of carrying. message usage is relatively simple.\r\n\r\nAlthough there are public Message default constructor, but you should () to get empty message object from a message pool by Message.obtain, to save resources.\r\n\r\nIf you only need to carry a simple message int information, priority Message.arg1 and Message.arg2 to convey information, which is more provincial than the Bundle memory\r\n\r\nMessage.what to identify unauthorized information in order to process message in different ways.\r\n\r\nLooper\r\n\r\n  Looper literally means \"those who cycle\", which is designed to enable a common thread becomes Looper thread. Looper thread is the so-called cycle work thread. Program development (especially GUI development), we often need a continuous cycle of threads, once there is a new task is executed, executing the task continues to wait for the next, which is Looper thread. Create Looper Looper thread class is simple:\r\n\r\npublic  class  LooperThread  extends  Thread  {\r\n     Override \r\n    public  void  run ()  {\r\n         // initialize the current thread to Looper thread\r\n        Looper.prepare ();\r\n\r\n        // ... Other treatments, such as instantiation handler\r\n\r\n        // Begin loop processing the message queue\r\n        Looper.loop ();\r\n    }\r\n}\r\n\r\n\r\n  Looper is now a subject of your thread, its internal maintains a message queue MQ. Note that a Thread can have only one Looper objects\r\n\r\n  prepare () the core is defined as the looper objects ThreadLocal.\r\n\r\n  loop (); after calling loop method, Looper thread began to really work, and it continues to remove the team from his head MQ messages (also called task).\r\n\r\n\r\n\r\n  In addition to prepare () and loop () method, Looper class also provides some useful methods, such as\r\n\r\nLooper.myLooper () to get the current thread looper objects\r\ngetThread () to get the object belongs looper thread\r\nquit () method to end looper loop\r\nAbout Looper summary points:\r\n\r\nEach thread has one and can only have a Looper object, which is a ThreadLocal\r\nLooper has an internal message queue, loop () method after calling thread began to remove the message from the queue to perform\r\nLooper Looper make a thread into a thread.\r\nMessageQueue\r\n\r\n  Message Queue (Message Queue), but MQ is encapsulated into Looper inside, we do not deal directly with MQ\r\n\r\n'\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nHandler main thread delay implementation of the program\r\n  Here are some of the use of each APP APP interface products interlude cases, delay in the description of the main thread execution, but does not block the main thread is the handler of message mechanism mainly used to send a message in the post way.\r\n\r\nCase\r\n\r\n\r\npublic  class  WelcomeActivity  extends  AppCompatActivity  {\r\n\r\n    // Create Handler object in the main thread \r\n    Handler handler = new Handler ();\r\n     Override \r\n    protected  void  onCreate (Bundle savedInstanceState)  {\r\n         Super .onCreate (savedInstanceState);\r\n        setContentView (R.layout.activity_main);\r\n        // Use postDelayed delay 5000 execution method, so it will not block the main thread \r\n        handler.postDelayed ( new Runnable () {\r\n             Override \r\n            public  void  run ()  {\r\n                 // here is still the main thread \r\n                // jump to other Activity \r\n                Intent Intent = new Intent ( \"com.hzj163.myhandler.MainActivity\" );\r\n                startActivity (intent);\r\n                finish ();\r\n            }\r\n        }, 5000 );\r\n    }\r\n\r\n}\r\nHandler communication between threads and threads\r\n  In the second thread is instantiated Handler must ensure that secondary thread opened Looper otherwise trigger Can not create handler inside thread that has not called Looper.prepare ()\r\n\r\nCase\r\n\r\n\r\n\r\nPackage com.hzj163.myhandler;\r\n\r\nImport android.os.Handler;\r\n Import android.os.Looper;\r\n Import android.os.Message;\r\n Import android.support.v4.app.INotificationSideChannel;\r\n Import android.support.v7.app.ActionBar;\r\n Import android.support.v7. app.AppCompatActivity;\r\n Import android.os.Bundle;\r\n Import android.util.Log;\r\n Import android.view.Menu;\r\n Import android.view.MenuItem;\r\n Import android.view.SurfaceView;\r\n Import android.view.View;\r\n Import android.widget .TextView;\r\n\r\nImport java.util.Timer;\r\n Import java.util.TimerTask;\r\n public  class  MainActivity  extends  AppCompatActivity  {\r\n    TextView textView2;\r\n    int a = 900 ;\r\n     Override \r\n    protected  void  onCreate (Bundle savedInstanceState)  {\r\n         Super .onCreate (savedInstanceState);\r\n        setContentView (R.layout.activity_main2);\r\n        textView2 = (TextView) findViewById (R.id.textView2);\r\n        // Start the secondary thread 1, ready to receive a message waiting for \r\n        new Thread (runnable1) .start ();\r\n    }\r\n\r\n    // Main thread Handler object \r\n    Handler handlerMain = new Handler ();\r\n     // second thread Handler objects\r\n    Handler handlerThread;\r\n    // Secondary thread 1, is responsible for receiving messages \r\n    in the second thread 1 // Internal run method instantiates Handler object HandlerThread \r\n    Runnable runnable1 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n             // Looper ready\r\n            Looper.prepare ();\r\n            // Instantiate handlerThread, only in the run inside an instance method of handlerThread valid \r\n            HandlerThread = new Handler () {\r\n                 // callback handleMessage prepared to accept the message \r\n                Override \r\n                public  void  handleMessage (Message msg)  {\r\n                    Log.i ( \"HZJ\" , \"began the received message Thread:\" + Thread.currentThread () getName ().);\r\n                     Final  int temp = msg.arg1;\r\n                     // perform the update using the main UI thread is the main thread of handlerMain objects \r\n                    handlerMain. post ( new Runnable () {\r\n                         Override \r\n                        public  void  run ()  {\r\n                             // update the UI \r\n                            textView2.setText ( \"a: =\" + temp);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            // Looper start the cycle\r\n            Looper.loop ();\r\n        }\r\n    };\r\n    // Thread 2: Mainly responsible for sending a message, send a message to the thread 1, so need to use handlerThread object to a message \r\n    Runnable runnable2 = new Runnable () {\r\n         Override \r\n        public  void  run ()  {\r\n            Log.i ( \"HZJ\" , \"develop a message: Thread:\" + Thread.currentThread () getName ().);\r\n            a = 1000 ;\r\n             // create a message object HandlerThread, because at times the thread 1 handlerThread\r\n            Message message = handlerThread.obtainMessage ();\r\n            message.arg1 = a;\r\n            // Send messages, thread 1 handlerThread to receive news, reaching the thread 2 and thread communication\r\n            message.sendToTarget ();\r\n        }\r\n    };\r\n\r\n    public  void  btn2 (View View)  {\r\n         // interaction between threads and thread \r\n        // open thread 2, start sending a message to the thread 1 \r\n        new Thread (runnable2) .start ();\r\n    }\r\n\r\n    Override \r\n    protected  void  onDestroy ()  {\r\n\r\n        // Note that you need to close the secondary thread Looper 1 \r\n        if (HandlerThread! = null ) {\r\n             // close of the thread Looper 1\r\n            handlerThread.getLooper () quit ().;\r\n        }\r\n        Super .onDestroy ();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n輸入並搜尋\r\nAndroid Thread\r\nBrief introduction\r\n1. JAVA thread creation\r\n2. JAVA cyclic thread\r\n3. Thread Synchronization JAVA\r\n4. JAVA thread object copy ThreadLocal\r\n5. JAVA thread pool\r\n6. Android messaging\r\n7. Android messaging communication thread between the thread\r\n8. Android asynchronous task AsyncTask\r\nThis book uses GitBook release\r\nAndroid Thread\r\nAsyncTask\r\n  AsyncTask is Android 1.5 Cubake join a class to implement asynchronous operations, before only with Java SE library Thread to achieve multi-threaded asynchronous, AsyncTask Android platform is its asynchronous tools, into the characteristics of the Android platform, Let asynchronous operation more secure, convenient and practical. It is also essentially a wrapper for Java SE library Thread, coupled with the platform-dependent features, so for all multi-threaded asynchronous strongly recommended to use AsyncTask, because it takes into account, but also into the characteristics of the Android platform is more secure and efficient.\r\n\r\n  AsyncTask can easily perform asynchronous operations (doInBackground), but also easy to communicate with the main thread, which itself and good encapsulation, can cancel the operation (cancel ()).\r\n\r\n  AsyncTask objects can not be reused, meaning that a AsyncTask object can only execute () once, or there will be an exception is thrown \"java.lang.IllegalStateException: Can not execute task: the task is already running\"\r\n\r\nPrevious version Android2.3, namely SDK / 10 and previous versions of API\r\n\r\nInternal thread pool limit is 5, which means that while there are only five threads running over the threads can only wait, wait in front of the thread was only an execution schedule and run over. In other words, if AsyncTask number of instances of a process of more than five, so if the previous five runs for a long time, then wait for the first six only chance. This is a limitation AsyncTask, but also for the previous version 2.3 can not be solved. If your application requires a lot of background thread to perform the task, then you can give up the use AsyncTask, create your own thread pool to manage Thread, or simply do not directly use the thread pool Thread it anyway. Have to say, though relatively Thread AsyncTask more convenient to use, but it can only run five threads simultaneously, which greatly limited its strength, you have to be careful to design your application, use staggered AsyncTask time, try to do time-sharing, or ensure that the number is not more than five, otherwise we may encounter problems mentioned above.\r\nAndroid 3.0 later, that SDK / 11 and later versions of API.\r\n\r\nSent some specific changes\r\n\r\nexecute () submitted task, according to the order that you run only one to say it is in the order of submission, a time to start a thread to perform a task, then run after the completion of the second task, which is the equivalent of only one task background thread executing submitted (Executors.newSingleThreadPool ()).\r\n\r\nNew interface executeOnExecutor (). This interface allows developers to provide custom thread pool to run and schedule Thread, if you want all the tasks can be run concurrently at the same time, then there is no limit to create a thread pool (Executors.newCachedThreadPool ()), and provided to AsyncTask. Such examples of this AsyncTask had its own thread pool without using AsyncTask default.\r\n\r\nAdded predefined thread pool THREAD_POOL_EXECUTOR. In fact THREAD_POOL_EXECUTOR not new, before there, but before (Android 2.3) it is AsyncTask private, not public only. THREAD_POOL_EXECUTOR corePoolSize thread pool is a 5, meaning that only a maximum of five threads to run simultaneously, more than five of would wait. So if you use executeOnExecutor (AsyncTask.THREAD_POOL_EXECUTOR) just 2.3 version AsyncTask.execute () effect is the same.\r\n\r\nAdded predefined thread pool SERIAL_EXECUTOR, its role is to guarantee the order of task execution, that is, it can ensure the task is indeed submitted in accordance with the order execution. Its interior has a queue for storing a job submitted to ensure the current run only one, so that you can ensure the task is in full accordance with the order of execution, the default execute () is used for this, which is executeOnExecutor (AsyncTask.SERIAL_EXECUTOR) and execute () is the same\r\n\r\nNote the use of AsyncTask\r\n\r\nOverhead thread is very large, while asynchronous processing is also error-prone and difficult to debug, difficult to maintain, so improve your design, as little as possible with asynchronous. For general database queries, a small number of I / O operations are not necessary to start the thread.\r\nWhen using AsyncTask have interaction with the main thread, otherwise use Thread\r\n\r\nAsyncTask was designed purpose is to meet the specific needs of Android: non-main thread can not operate (UI) components, so AsyncTask extend Thread enhances the ability to interact with the main thread. If your application does not interact with the main thread, then the direct use of Thread enough.\r\n\r\nWhen a large number of threads needed to perform tasks, we must create a thread pool\r\n\r\nOverhead thread is very large, especially to create a new thread, otherwise it does not have to design the thread pool like tool. When a large number of threads required to perform tasks, we must create a thread pool using either AsyncTask or Thread, because the use of its internal thread pool AsyncTask quantitative restrictions, may not meet the demand; it is to use Thread thread pool to manage, avoid virtual machine create a large number of threads. For example, batch download pictures from the Internet, you do not want one by one under, or 5 5 download, then create a thread pool CorePoolSize 10 or 20, every 10 or 20 such download is met speed, but not so useless consuming performance overhead to create unlimited threads.\r\n\r\nFor asynchronous task you want to begin immediately, either directly using the Thread, or create a separate thread pool available to AsyncTask\r\n\r\nThe default AsyncTask will not necessarily perform your task immediately, unless you offer to give him a separate thread pool. If you do not interact with the main thread, you can directly create a Thread, although the creation of threads overhead is relatively large, but if this is not the batch operation is no problem.\r\n\r\nAsyncTask schematic\r\n\r\n\r\n\r\n\r\n\r\nCase\r\n\r\n\r\nPackage com.hzj163.myasynctask;\r\n\r\nImport android.os.AsyncTask;\r\n Import android.support.v7.app.AppCompatActivity;\r\n Import android.os.Bundle;\r\n Import android.view.View;\r\n Import android.widget.ProgressBar;\r\n Import android.widget.TextView;\r\n Import android.widget .Toast;\r\n\r\npublic  class  MainActivity  extends  AppCompatActivity  {\r\n    ProgressBar progressBar1;\r\n    TextView textView1;\r\n    MyAsyncTask myAsyncTask;\r\n    // AsyncTask <Params, Progress, Result> \r\n    // URL Params start task execution input parameters, such as HTTP requests \r\n    percentage // Progress background tasks. \r\n    // Result Results eventual return of background tasks, such as String. \r\n    class  MyAsyncTask  extends  AsyncTask < Integer , Integer , String > {\r\n         // before the main thread begins execution [] [initial work, because in the main UI thread} \r\n        // only once \r\n        Override \r\n        protected  void  onPreExecute ()  {\r\n            textView1.setText ( \"0%\" );\r\n            progressBar1.setMax ( 100 );\r\n            progressBar1.setProgress ( 0 );\r\n        }\r\n\r\n        // Place the results of [the main thread], generally used for updating UI \r\n        // parameters: the implementation of the results \r\n        will only be executed once // \r\n        Override \r\n        protected  void  onPostExecute (String Description)  {\r\n            Toast.makeText (. MainActivity this , Description, Toast.LENGTH_LONG) .Show ();\r\n            textView1.setText ( \"0%\" );\r\n            progressBar1.setMax ( 100 );\r\n            progressBar1.setProgress ( 0 );\r\n        }\r\n\r\n        // Background, more time-consuming operations can be placed here. \r\n        // Here is the [second thread] \r\n        // parameters: thread begins execution when the parameters corresponding to [AsyncTask <Params, Progress, Result> The Params] \r\n        // Return: corresponding to [AsyncTask <Params, Progress, Result> in The Result, primarily to onPostExecute Usage \r\n        Override \r\n        protected String doInBackground (Integer ... params)  {\r\n             for ( int i = 0 ; i <params [ 0 ]; i ++) {\r\n                 try {\r\n                    Thread.sleep ( 1000 );\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace ();\r\n                }\r\n                // PublicProgress (Progress ...) to update the progress of the task.\r\n                publishProgress (i);\r\n            }\r\n            return  \"is finished!\" ;\r\n        }\r\n\r\n        // You can use a progress bar to increase the user experience. This method is the main thread of execution, for the progress display tasks. \r\n        // This is the main thread] [ \r\n        //// parameters: thread begins execution when the parameters corresponding to [AsyncTask <Params, Progress, Result> The Params] \r\n        Override \r\n        protected  void  onProgressUpdate (Integer ... values)  {\r\n            textView1.setText (values ​​[ 0 ] + \"%\" );\r\n            progressBar1.setProgress (values ​​[ 0 ]);\r\n        }\r\n\r\n        // Invoked when the user canceled the main thread to do the operation [] \r\n        // only once \r\n        Override \r\n        protected  void  onCancelled (String Description)  {\r\n        }\r\n\r\n        // Invoked when the user canceled the main thread to do the operation [] \r\n        // only once \r\n        Override \r\n        protected  void  onCancelled ()  {\r\n        }\r\n    }\r\n\r\n    public  void  btn1 (View View)  {\r\n         // instantiate asynchronous tasks \r\n        myAsyncTask = new MyAsyncTask ();\r\n         // begin to perform asynchronous tasks \r\n        myAsyncTask.execute ( 100 );\r\n\r\n    }\r\n\r\n    Override \r\n    protected  void  onCreate (Bundle savedInstanceState)  {\r\n         Super .onCreate (savedInstanceState);\r\n        setContentView (R.layout.activity_main);\r\n        progressBar1 = (ProgressBar) findViewById (R.id.progressBar1);\r\n        textView1 = (TextView) findViewById (R.id.textView1);\r\n    }\r\n}\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}